# HAProxy configuration
#
# **** DO NOT EDIT THIS FILE ****
#
# This file is managed by Salt.
# Any changes will be overwritten.

{%- macro render_list_of_dictionaries(name, list, indent = '    ', infix = ' ', postfix = '\t') %}
{%- if list is not iterable or list is string %}
{{ indent ~ name ~ postfix ~ list }}
{%- else %}{% for item in list %}
{%- if item is not iterable or item is string %}
{{ indent ~ name ~ postfix ~ item }}
{%- else %}{% for key, value in item.items() %}
{{- render_list_of_dictionaries(indent ~ name ~ infix ~ key, value, '', infix, postfix) }}
        {%- endfor %}
      {%- endif %}
    {%- endfor %}
  {%- endif %}
{%- endmacro %}

{% set zinibu_basic = salt['pillar.get']('zinibu_basic', {}) -%}

#------------------
# Global settings
#------------------
global
    log /dev/log    local0
    log /dev/log    local1 notice
    #user {{ salt['pillar.get']('haproxy:global:user', 'haproxy') }}
    #group {{ salt['pillar.get']('haproxy:global:group', 'haproxy') }}
{%- if salt['pillar.get']('haproxy:global:chroot:enable', 'no') == True %}
    #chroot {{ salt['pillar.get']('haproxy:global:chroot:path', '/tmp') }}
{%- endif %}
{%- if salt['pillar.get']('haproxy:global:daemon', 'no') == True %}
    daemon
{%- endif %}
{%- if salt['pillar.get']('haproxy:global:stats:enable', 'no') == True %}
    stats socket {{ salt['pillar.get']('haproxy:global:stats:socketpath', '/tmp/ha_stats.sock') }}
{%- endif %}
{%- if 'maxconn' in salt['pillar.get']('haproxy:global', {}) %}
    maxconn {{ salt['pillar.get']('haproxy:global:maxconn') }}
{%- endif %}
{%- if 'maxpipes' in salt['pillar.get']('haproxy:global', {}) %}
    maxpipes {{ salt['pillar.get']('haproxy:global:maxpipes') }}
{%- endif %}
{%- if 'spreadchecks' in salt['pillar.get']('haproxy:global', {}) %}
    spread-checks {{ salt['pillar.get']('haproxy:global:spreadchecks') }}
{%- endif %}
{%- if 'tune' in salt['pillar.get']('haproxy:global', {}) %}
    {{- render_list_of_dictionaries('tune', salt['pillar.get']('haproxy:global:tune'), '    ','.') }}
{%- endif %}
    tune.ssl.default-dh-param 2048
{%- if 'ssl-default-bind-ciphers' in salt['pillar.get']('haproxy:global', {}) %}
    {{- render_list_of_dictionaries('ssl-default-bind-ciphers', salt['pillar.get']('haproxy:global:ssl-default-bind-ciphers')) }}
{%- endif %}
{%- if 'ssl-default-bind-options' in salt['pillar.get']('haproxy:global', {}) %}
    {{- render_list_of_dictionaries('ssl-default-bind-options', salt['pillar.get']('haproxy:global:ssl-default-bind-options')) }}
{%- endif %}

defaults
    log {{ salt['pillar.get']('haproxy:defaults:log', 'global') }}
    mode {{ salt['pillar.get']('haproxy:defaults:mode', 'http') }}
    retries {{ salt['pillar.get']('haproxy:defaults:retries', '3') }}
    default-server {{ salt['pillar.get']('haproxy:defaults:default-server', '') }}
{%- if 'options' in salt['pillar.get']('haproxy:defaults', {}) -%}
    {{- render_list_of_dictionaries('option', salt['pillar.get']('haproxy:defaults:options')) }}
{%- endif %}
{%- if 'timeouts' in salt['pillar.get']('haproxy:defaults', {}) %}
  {%- for timeout in salt['pillar.get']('haproxy:defaults:timeouts') %}
    timeout {{ timeout }}
  {%- endfor %}
{%- else %}
    timeout client  1m
    timeout connect 10s
    timeout server  1m
{%- endif %}
{%- if 'errorfiles' in salt['pillar.get']('haproxy:defaults', {}) %}
  {%- for errorfile in salt['pillar.get']('haproxy:defaults:errorfiles').iteritems() %}
    errorfile {{ errorfile[0] }} {{ errorfile[1] }}
  {%- endfor %}
{%- endif %}

# Stats use permanent public IPs so we can administer each server.
{% if 'haproxy_servers' in zinibu_basic.project %}
  {%- for id, haproxy_server in zinibu_basic.project.haproxy_servers.iteritems() %}
    {%- if grains['id'] == id %}
      {%- if 'stats' in haproxy_server %}
listen stats_{{ id }}
  {%- if haproxy_server.anchor_ip == '0.0.0.0' and grains['id'] == id %}
  bind {{ haproxy_server.public_ip }}:{{ haproxy_server.stats_port }}
  {%- else %}
  bind {{ haproxy_server.anchor_ip }}:{{ haproxy_server.stats_port }}
  {%- endif %}
        {%- for option, value in haproxy_server.stats.iteritems() %}
          {%- if option == 'enable' and value %}
  stats enable
          {%- else %}
  stats {{ option }} {{ value }}
          {%- endif %}
        {%- endfor %}
      {%- endif %}
    {%- endif %}
  {%- endfor %}
{% endif %}

# Main frontend dedicated to end users, if using Keepalived with Digital Ocean,
# this is the anchor IP for the floating IP. Get it with:
# curl 169.254.169.254/metadata/v1/interfaces/public/0/anchor_ipv4/address && echo
frontend ft_web
{%- if 'haproxy_servers' in zinibu_basic.project %}
  {%- for id, haproxy_server in zinibu_basic.project.haproxy_servers.iteritems() %}
    {%- if grains['id'] == id %}
      {%- if haproxy_server.anchor_ip == '0.0.0.0' and grains['id'] == id %}
    bind {{ zinibu_basic.project.haproxy_frontend_public_ip }}:{{ zinibu_basic.project.haproxy_frontend_port }} # public IP
      {%- else %}
    bind {{ haproxy_server.anchor_ip }}:{{ zinibu_basic.project.haproxy_frontend_port }} # anchor IP linked to floating IP
      {%- endif %}
    {%- endif %}
  {%- endfor %}
{%- endif %}
{%- if 'haproxy_ssl_cert' in zinibu_basic.project %}
    acl https ssl_fc
    http-request redirect scheme https if !https
    reqadd X-Forwarded-Proto:\ http

frontend www-https
{%- if 'haproxy_servers' in zinibu_basic.project %}
  {%- for id, haproxy_server in zinibu_basic.project.haproxy_servers.iteritems() %}
    {%- if grains['id'] == id %}
      {%- if haproxy_server.anchor_ip == '0.0.0.0' and grains['id'] == id %}
    bind {{ zinibu_basic.project.haproxy_frontend_public_ip }}:{{ zinibu_basic.project.haproxy_frontend_secure_port }}  ssl crt {{ zinibu_basic.project.haproxy_ssl_cert }} # public IP
      {%- else %}
    bind {{ haproxy_server.anchor_ip }}:{{ zinibu_basic.project.haproxy_frontend_secure_port }} ssl crt {{ zinibu_basic.project.haproxy_ssl_cert }} # anchor IP linked to floating IP
      {%- endif %}
    {%- endif %}
  {%- endfor %}
{%- endif %}
    acl has_www hdr_beg(host) -i www
    http-request redirect code 301 location https://www.%[req.hdr(Host)] if !has_www
    reqadd X-Forwarded-Proto:\ https
{%- endif %}
    acl static_content path_end .jpg .gif .png .css .js .htm .html .woff
    #acl pseudo_static path_end .php ! path_beg /dynamic/
    # user is logged-in to Django admin
    # This works in conjunction with a logged_in cookie
    # set on login and deleted on logout by your application.
    # Django middleware can do this. See django-zinibu-cache
    acl logged_in_user req.cook(logged_in) -m found
    acl image_dynamic path_beg /serve_image
    acl varnish_available nbsrv(bk_varnish_uri) ge 1

    # All use_backed rules are evaluated in their declaration order
    # the first one which matches will assign the backend
    # Caches health detection + routing decision
    use_backend bk_varnish_uri if varnish_available static_content
    #use_backend bk_varnish_uri if varnish_available pseudo_static
    use_backend bk_varnish_url_param if varnish_available image_dynamic
    use_backend bk_varnish_uri if varnish_available !logged_in_user
    # dynamic content or all caches are unavailable
    default_backend bk_appsrv

# appsrv backend for dynamic content
backend bk_appsrv
    balance roundrobin
    # app servers must say if everything is fine on their side
    # and they can process requests
    option httpchk
    option httpchk GET {{ zinibu_basic.project.haproxy_app_check_url }}
    http-check expect rstring {{ zinibu_basic.project.haproxy_app_check_expect }}
    cookie SERVERID insert indirect nocache
    # Transparent proxying using the client IP from the TCP connection
    #source 0.0.0.0 usesrc clientip
    # having troubles with that so we're using forwardfor
    option forwardfor
    #http-response set-header X-HAProxy-Debug bk_appsrv
{%- if 'webheads' in zinibu_basic.project %}
  {%- for id, webhead in zinibu_basic.project.webheads.iteritems() %}
    server app_{{ id }} {{ webhead.private_ip }}:{{ webhead.nginx_port }} cookie app_{{ id }} check maxconn {{ webhead.maxconn_dynamic }} 
  {%- endfor %}
{%- endif %}

# static backend with balance based on the uri, including the query string
# to avoid caching an object on several caches
backend bk_varnish_uri
    balance uri whole # in latest HAProxy version, one can add 'whole' keyword
    # Varnish must tell it's ready to accept traffic
    option httpchk HEAD {{ zinibu_basic.project.varnish_check }}
    http-check expect status 200
    # client IP information
    option forwardfor
    # avoid request redistribution when the number of caches changes (crash or start up)
    hash-type consistent
    #http-response set-header X-HAProxy-Debug bk_varnish_uri
{%- if 'varnish_servers' in zinibu_basic.project %}
  {%- for id, varnish_server in zinibu_basic.project.varnish_servers.iteritems() %}
    server cache_{{ id }} {{ varnish_server.private_ip }}:{{ varnish_server.port }} check maxconn {{ varnish_server.maxconn_cache }} 
  {%- endfor %}
{%- endif %}

# cache backend with balance based on the value of the URL parameter called "id"
# to avoid caching an object on several caches
backend bk_varnish_url_param
    balance url_param id
    # client IP information
    option forwardfor
    # avoid request redistribution when the number of caches changes (crash or start up)
    hash-type consistent
    #http-response set-header X-HAProxy-Debug bk_varnish_url_param
{%- if 'varnish_servers' in zinibu_basic.project %}
  {%- for id, varnish_server in zinibu_basic.project.varnish_servers.iteritems() %}
    server cache_{{ id }} {{ varnish_server.private_ip }}:{{ varnish_server.port }} maxconn {{ varnish_server.maxconn_cache }} track bk_varnish_uri/cache_{{ id }}
  {%- endfor %}
{%- endif %}

# Frontend used by Varnish servers when updating their cache. Private IPs.
# bind uses a comma separated list of addresses.
# see: http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#bind
frontend ft_web_static
    bind {% for id, haproxy_server in zinibu_basic.project.haproxy_servers.iteritems() %}{{ haproxy_server.private_ip }}:{{ haproxy_server.varnish_port }},{% endfor %}
    monitor-uri {{ zinibu_basic.project.haproxy_check }}
    acl no_webheads_available nbsrv(bk_appsrv_static) eq 0
    # Tells Varnish to stop asking for static content when app servers (webheads) are dead
    # Varnish would deliver staled content
    monitor fail if no_webheads_available
    default_backend bk_appsrv_static

# appsrv backend used by Varnish to update their cache
backend bk_appsrv_static
    balance roundrobin
    # anything different than a status code 200 on the URL /staticcheck.txt
    # must be considered as an error
    option httpchk HEAD {{ zinibu_basic.project.haproxy_static_check_url }}
    http-check expect status 200
    # Transparent proxying using the client IP provided by X-Forwarded-For header
    # having troubles with that so we're using forwardfor
    #source 0.0.0.0 usesrc hdr_ip(X-Forwarded-For)
    option forwardfor
    #http-response set-header X-HAProxy-Debug bk_appsrv_static
{%- if 'webheads' in zinibu_basic.project %}
  {%- for id, webhead in zinibu_basic.project.webheads.iteritems() %}
    server app_{{ id }} {{ webhead.private_ip }}:{{ webhead.nginx_port }} check maxconn {{ webhead.maxconn_static }} slowstart {{ webhead.slowstart }}
  {%- endfor %}
{%- endif %}
