#------------------
# Global settings
#------------------
global
    daemon
    stats socket /var/lib/haproxy/stats
    tune.ssl.default-dh-param 2048

defaults
    mode http
    retries 3
    default-server inter 3s fall 2 rise 2 slowstart 60s
    option	httplog
    option	http-server-close
    timeout connect         5s
    timeout client          1m
    timeout server          1m
    timeout check           10s
    timeout http-keep-alive 10s
    timeout http-request    10s
    timeout queue           1m

listen stats
  bind :8998
  stats enable
  stats realm HAProxyStatistics1
  stats show-desc Primary load balancer
  stats uri /admin?stats
  stats refresh 20s
  stats hide-version 
  stats auth admin:admin

# Main frontend dedicated to end users,
frontend ft_web
    bind :80
    acl https ssl_fc
    http-request redirect scheme https if !https
    reqadd X-Forwarded-Proto:\ http

frontend www-https
    bind :443 ssl crt /srv/haproxy/ssl/certificate.pem
    acl has_www hdr_beg(host) -i www
    http-request redirect code 301 location https://www.%[req.hdr(Host)] if !has_www
    reqadd X-Forwarded-Proto:\ https
    acl static_content path_end .jpg .gif .png .css .js .htm .html .woff
    #acl pseudo_static path_end .php ! path_beg /dynamic/
    # user is logged-in to Django admin
    # This works in conjunction with a logged_in cookie
    # set on login and deleted on logout by your application.
    # Django middleware can do this. See django-zinibu-cache
    #acl logged_in_user req.cook(logged_in) -m found
    #acl image_dynamic path_beg /serve_image
    acl varnish_available nbsrv(bk_varnish_uri) ge 1

    # All use_backed rules are evaluated in their declaration order
    # the first one which matches will assign the backend
    # Caches health detection + routing decision
    use_backend bk_varnish_uri if varnish_available static_content
    #use_backend bk_varnish_uri if varnish_available pseudo_static
    use_backend bk_varnish_url_param if varnish_available image_dynamic
    use_backend bk_varnish_uri if varnish_available !logged_in_user
    # dynamic content or all caches are unavailable
    default_backend bk_appsrv

# appsrv backend for dynamic content
backend bk_appsrv
    balance roundrobin
    option httpchk
    option httpchk GET /app-check/
    http-check expect rstring [oO][kK]
    cookie SERVERID insert indirect nocache
    # Transparent proxying using the client IP from the TCP connection
    #source 0.0.0.0 usesrc clientip
    # having troubles with that so we're using forwardfor
    option forwardfor
    #http-response set-header X-HAProxy-Debug bk_appsrv
    server web1 web1:80 cookie web1 check maxconn 250

# static backend with balance based on the uri, including the query string
# to avoid caching an object on several caches
backend bk_varnish_uri
    balance uri whole # in latest HAProxy version, one can add 'whole' keyword
    # Varnish must tell it's ready to accept traffic
    option httpchk HEAD /varnishcheck
    http-check expect status 200
    # client IP information
    option forwardfor
    # avoid request redistribution when the number of caches changes (crash or start up)
    hash-type consistent
    #http-response set-header X-HAProxy-Debug bk_varnish_uri
    server cache1 cache1:83 check maxconn 1000

# cache backend with balance based on the value of the URL parameter called "id"
# to avoid caching an object on several caches
#backend bk_varnish_url_param
#    balance url_param id
#    # client IP information
#    option forwardfor
#    # avoid request redistribution when the number of caches changes (crash or start up)
#    hash-type consistent
#    #http-response set-header X-HAProxy-Debug bk_varnish_url_param
#    server cache1 cache1:83 maxconn 1000 track bk_varnish_uri/cache1
#
## Frontend used by Varnish servers when updating their cache. Private IPs.
## bind uses a comma separated list of addresses.
## see: http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#bind
#frontend ft_web_static
#    bind 172.31.63.150:80,
#    monitor-uri /haproxycheck
#    acl no_webheads_available nbsrv(bk_appsrv_static) eq 0
#    # Tells Varnish to stop asking for static content when app servers (webheads) are dead
#    # Varnish would deliver staled content
#    monitor fail if no_webheads_available
#    default_backend bk_appsrv_static
#
## appsrv backend used by Varnish to update their cache
#backend bk_appsrv_static
#    balance roundrobin
#    # anything different than a status code 200 on the URL /staticcheck.txt
#    # must be considered as an error
#    option httpchk HEAD /static/znbmain/static-check.txt
#    http-check expect status 200
#    # Transparent proxying using the client IP provided by X-Forwarded-For header
#    # having troubles with that so we're using forwardfor
#    #source 0.0.0.0 usesrc hdr_ip(X-Forwarded-For)
#    option forwardfor
#    #http-response set-header X-HAProxy-Debug bk_appsrv_static
#    server app_web1 web1:80 check maxconn 50 slowstart 10s
